package gg.essential.vigilance.utils

import gg.essential.elementa.components.UIImage
import gg.essential.elementa.utils.ResourceCache
import gg.essential.vigilance.gui.common.AutoImageSize
import java.awt.Color

/**
 * Stores settings and options applied to every [UIImage] generated by an [ImageFactory]
 *
 * @property autoSize Whether the generated image should automatically have its width and height set to same value as the loaded texture
 * @property color The initial color the generated image should be set to
 * @property minFilter The texture min filter parameter OpenGL should use when rendering this image
 * @property magFilter The texture mag filter parameter OpenGL should use when rendering this image
 */
internal data class ImageGeneratorSettings(
    val autoSize: Boolean = true,
    val color: Color = Color.WHITE,
    val minFilter: UIImage.TextureScalingMode = UIImage.TextureScalingMode.NEAREST,
    val magFilter: UIImage.TextureScalingMode = UIImage.TextureScalingMode.NEAREST,
)

/**
 * An ImageFactory is a utility class for creating instances of a [UIImage]
 *
 * Each ImageFactory should only ever produce images for a single resource.
 *
 * Calls to [create] are non-blocking and automatically apply [settings] to the generated image.
 *
 */
internal abstract class ImageFactory(
    protected val settings: ImageGeneratorSettings = ImageGeneratorSettings()
) {
    // Tracks whether this ImageFactory has loaded its resource at least once
    private var loadedOnce = false

    /**
     * Stores whether this ImageFactory supports the caching of its resource
     * Calls to [preload] when supportsCaching is false will result in nothing
     */
    abstract val supportsCaching: Boolean

    /**
     * Produces a new [UIImage] and applies [settings]
     */
    fun create(): UIImage {
        return generate().apply {
            loadedOnce = true
            if (settings.autoSize) {
                supply(AutoImageSize(this))
            }
            textureMinFilter = settings.minFilter
            textureMagFilter = settings.magFilter
            setColor(settings.color)
        }
    }

    /**
     * Produces a new [UIImage]
     *
     * This method should be non-blocking. Any IO operation required to load
     * the texture of the image should happen on another thread.
     */
    protected abstract fun generate(): UIImage

    /**
     * Calls [create] if this ImageFactory supports caching and [create]
     * has not been called at least once before.
     */
    fun preload(): ImageFactory {
        if (!loadedOnce && supportsCaching) {
            create()
        }
        return this
    }

    /**
     * @return a clone of this ImageFactory with the color setting changed
     */
    fun withColor(color: Color): ImageFactory {
        return DelegatedImageImageFactory(
            this,
            settings.copy(color = color)
        )
    }

    /**
     * @return a clone of this ImageFactory with the texture scaling settings changed
     */
    fun withTextureScaling(minFilter: UIImage.TextureScalingMode, magFilter: UIImage.TextureScalingMode): ImageFactory {
        return DelegatedImageImageFactory(
            this,
            settings.copy(
                minFilter = minFilter,
                magFilter = magFilter
            )
        )
    }

    /**
     * @return a clone of this ImageFactory with the supplied settings
     */
    open fun withSettings(settings: ImageGeneratorSettings): ImageFactory {
        return DelegatedImageImageFactory(this, settings)
    }

}

/**
 * An ImageFactory that delegates the generation of images to the [innerSupplier] with the supplied [settings]
 */
private class DelegatedImageImageFactory(
    private val innerSupplier: ImageFactory,
    settings: ImageGeneratorSettings
) : ImageFactory(settings) {

    override val supportsCaching: Boolean by innerSupplier::supportsCaching

    override fun generate(): UIImage {
        return innerSupplier.create()
    }

    override fun withSettings(settings: ImageGeneratorSettings): ImageFactory {
        return DelegatedImageImageFactory(innerSupplier, settings)
    }

}

/**
 * An ImageFactory that returns images resulting from the specified [resource].
 * Utilizes a [ResourceCache] to decrease loading time
 */
internal class ResourceImageFactory(
    private val resource: String,
    preload: Boolean = true
) : ImageFactory() {

    init {
        if (preload) {
            preload()
        }
    }

    override val supportsCaching: Boolean = true

    override fun generate(): UIImage {
        return UIImage.ofResourceCached(resource, cache)
    }

    private companion object {

        val cache: ResourceCache = ResourceCache(Int.MAX_VALUE)

    }
}

/**
 * An ImageFactory that supplies the images through the provided [generator] function
 * Does not support caching.
 */
internal fun ImageFactory(
    generator: () -> UIImage,
): ImageFactory = object : ImageFactory() {

    override var supportsCaching: Boolean = false

    override fun generate(): UIImage {
        return generator()
    }
}